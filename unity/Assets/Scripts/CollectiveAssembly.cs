// <auto-generated /> using Quicktype from json to C#.
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using CollectiveAssembly;
//
//    var assembly = Assembly.FromJson(jsonString);

// Collective Assembly structure as derived from the json file.
namespace CollectiveAssembly
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Assembly
    {
        [JsonProperty("compas")]
        public Compas Compas { get; set; }

        [JsonProperty("datatype")]
        public string Datatype { get; set; }

        [JsonProperty("data")]
        public AssemblyData Data { get; set; }
    }

    public partial class AssemblyData
    {
        [JsonProperty("adjacency")]
        public Dictionary<string, Dictionary<string, EdgeAttributes>> Adjacency { get; set; }

        [JsonProperty("node_attributes")]
        public NodeAttributes NodeAttributes { get; set; }

        [JsonProperty("node")]
        public Dictionary<string, Node> Node { get; set; }

        [JsonProperty("max_int_key")]
        public long MaxIntKey { get; set; }

        [JsonProperty("attributes")]
        public Attributes Attributes { get; set; }

        [JsonProperty("edge_attributes")]
        public EdgeAttributes EdgeAttributes { get; set; }

        [JsonProperty("edge")]
        public Dictionary<string, Dictionary<string, EdgeAttributes>> Edge { get; set; }
    }

    public partial class EdgeAttributes
    {
    }

    public partial class Attributes
    {
        [JsonProperty("name")]
        public string Name { get; set; }
    }

    public partial class Node
    {
        [JsonProperty("z")]
        public double Z { get; set; }

        [JsonProperty("idx_u")]
        public long IdxU { get; set; }

        [JsonProperty("idx_v")]
        public long IdxV { get; set; }

        [JsonProperty("is_flipped")]
        public bool IsFlipped { get; set; }

        [JsonProperty("element")]
        public Element Element { get; set; }

        [JsonProperty("voxel_b")]
        public Voxel VoxelB { get; set; }

        [JsonProperty("voxel_a")]
        public Voxel VoxelA { get; set; }

        [JsonProperty("phase_1", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Phase1 { get; set; }

        [JsonProperty("y")]
        public double Y { get; set; }

        [JsonProperty("x")]
        public double X { get; set; }

        [JsonProperty("is_support", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsSupport { get; set; }

        [JsonProperty("phase_2", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Phase2 { get; set; }

        [JsonProperty("is_built", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsBuilt { get; set; }

        [JsonProperty("phase_3", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Phase3 { get; set; }
    }

    public partial class Element
    {
        [JsonProperty("_source")]
        public Source Source { get; set; }

        [JsonProperty("_mesh")]
        public Mesh Mesh { get; set; }

        [JsonProperty("frame")]
        public Frame Frame { get; set; }
    }

    public partial class Frame
    {
        [JsonProperty("yaxis")]
        public double[] Yaxis { get; set; }

        [JsonProperty("xaxis")]
        public double[] Xaxis { get; set; }

        [JsonProperty("point")]
        public double[] Point { get; set; }
    }

    public partial class Mesh
    {
        [JsonProperty("compas")]
        public Compas Compas { get; set; }

        [JsonProperty("datatype")]
        public Datatype Datatype { get; set; }

        [JsonProperty("data")]
        public MeshData Data { get; set; }
    }

    public partial class MeshData
    {
        [JsonProperty("facedata")]
        public Dictionary<string, EdgeAttributes> Facedata { get; set; }

        [JsonProperty("dva")]
        public Dva Dva { get; set; }

        [JsonProperty("face")]
        public Dictionary<string, long[]> Face { get; set; }

        [JsonProperty("edgedata")]
        public EdgeAttributes Edgedata { get; set; }

        [JsonProperty("dfa")]
        public EdgeAttributes Dfa { get; set; }

        [JsonProperty("max_vertex")]
        public long MaxVertex { get; set; }

        [JsonProperty("dea")]
        public EdgeAttributes Dea { get; set; }

        [JsonProperty("attributes")]
        public Attributes Attributes { get; set; }

        [JsonProperty("max_face")]
        public long MaxFace { get; set; }

        [JsonProperty("vertex")]
        public Dictionary<string, Dva> Vertex { get; set; }
    }

    public partial class Dva
    {
        [JsonProperty("y")]
        public double Y { get; set; }

        [JsonProperty("x")]
        public double X { get; set; }

        [JsonProperty("z")]
        public double Z { get; set; }
    }

    public partial class Source
    {
        [JsonProperty("data")]
        public Mesh Data { get; set; }

        [JsonProperty("dtype")]
        public SourceDtype Dtype { get; set; }
    }

    public partial class Voxel
    {
        [JsonProperty("dtype")]
        public VoxelADtype Dtype { get; set; }

        [JsonProperty("value")]
        public Frame Value { get; set; }
    }

    public partial class NodeAttributes
    {
        [JsonProperty("is_built")]
        public bool IsBuilt { get; set; }

        [JsonProperty("is_placed")]
        public bool IsPlaced { get; set; }

        [JsonProperty("is_planned")]
        public bool IsPlanned { get; set; }

        [JsonProperty("y")]
        public long Y { get; set; }

        [JsonProperty("x")]
        public long X { get; set; }

        [JsonProperty("z")]
        public long Z { get; set; }

        [JsonProperty("is_flipped")]
        public bool IsFlipped { get; set; }

        [JsonProperty("idx_u")]
        public object IdxU { get; set; }

        [JsonProperty("voxel_b")]
        public object VoxelB { get; set; }

        [JsonProperty("voxel_a")]
        public object VoxelA { get; set; }

        [JsonProperty("idx_v")]
        public object IdxV { get; set; }

        [JsonProperty("is_support")]
        public bool IsSupport { get; set; }

        [JsonProperty("phase_1")]
        public bool Phase1 { get; set; }

        [JsonProperty("phase_3")]
        public bool Phase3 { get; set; }

        [JsonProperty("phase_2")]
        public bool Phase2 { get; set; }
    }

    public enum Compas { The163 };

    public enum Datatype { CompasDatastructuresMesh };

    public enum SourceDtype { CompasDatastructuresMeshMeshMesh };

    public enum VoxelADtype { CompasGeometryFrame };

    public partial class Assembly
    {
        public static Assembly FromJson(string json) => JsonConvert.DeserializeObject<Assembly>(json, CollectiveAssembly.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Assembly self) => JsonConvert.SerializeObject(self, CollectiveAssembly.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CompasConverter.Singleton,
                DatatypeConverter.Singleton,
                SourceDtypeConverter.Singleton,
                VoxelADtypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CompasConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Compas) || t == typeof(Compas?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "1.6.3")
            {
                return Compas.The163;
            }
            throw new Exception("Cannot unmarshal type Compas");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Compas)untypedValue;
            if (value == Compas.The163)
            {
                serializer.Serialize(writer, "1.6.3");
                return;
            }
            throw new Exception("Cannot marshal type Compas");
        }

        public static readonly CompasConverter Singleton = new CompasConverter();
    }

    internal class DatatypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Datatype) || t == typeof(Datatype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "compas.datastructures/Mesh")
            {
                return Datatype.CompasDatastructuresMesh;
            }
            throw new Exception("Cannot unmarshal type Datatype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Datatype)untypedValue;
            if (value == Datatype.CompasDatastructuresMesh)
            {
                serializer.Serialize(writer, "compas.datastructures/Mesh");
                return;
            }
            throw new Exception("Cannot marshal type Datatype");
        }

        public static readonly DatatypeConverter Singleton = new DatatypeConverter();
    }

    internal class SourceDtypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SourceDtype) || t == typeof(SourceDtype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "compas.datastructures.mesh._mesh/Mesh")
            {
                return SourceDtype.CompasDatastructuresMeshMeshMesh;
            }
            throw new Exception("Cannot unmarshal type SourceDtype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SourceDtype)untypedValue;
            if (value == SourceDtype.CompasDatastructuresMeshMeshMesh)
            {
                serializer.Serialize(writer, "compas.datastructures.mesh._mesh/Mesh");
                return;
            }
            throw new Exception("Cannot marshal type SourceDtype");
        }

        public static readonly SourceDtypeConverter Singleton = new SourceDtypeConverter();
    }

    internal class VoxelADtypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VoxelADtype) || t == typeof(VoxelADtype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "compas.geometry/Frame")
            {
                return VoxelADtype.CompasGeometryFrame;
            }
            throw new Exception("Cannot unmarshal type VoxelADtype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VoxelADtype)untypedValue;
            if (value == VoxelADtype.CompasGeometryFrame)
            {
                serializer.Serialize(writer, "compas.geometry/Frame");
                return;
            }
            throw new Exception("Cannot marshal type VoxelADtype");
        }

        public static readonly VoxelADtypeConverter Singleton = new VoxelADtypeConverter();
    }
}
